/* ----------------------------------------------------------------------- *//** 
 *
 * @file kmeans.sql_in
 *
 * @brief Set of functions for k-means clustering.
 *
 * @sa For a brief introduction to k-means clustering, see the module
 *     description \ref grp_kmeans.
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')

/**
@addtogroup grp_kmeans 

@about

Clustering refers to the problem of partitioning a set of objects according to
some problem-dependent measure of <em>similarity</em>. In the k-means variant,
one is given \f$ n \f$ points \f$ x_1, \dots, x_n \in \mathbb R^d \f$, and the goal is
to position \f$ k \f$ centroids \f$ c_1, \dots, c_k \in \mathbb R^d \f$ so that the sum of squared
distances between each point and its closest centroid is minimized. (A cluster
is identified by its centroid and consists of all points for which this
centroid is closest.) Formally, we wish to minimize the following objective
function:
\f[
    (c_1, \dots, c_k) \mapsto \sum_{i=1}^n \min_{j=1}^k \operatorname{dist}(x_i, c_j)^2
\f]

This problem is computationally difficult (NP-hard), yet the
local-search heuristic proposed by Lloyd [4] performs reasonably well in
practice. In fact, it is so ubiquitous today that it is
often referred to as the <em>standard algorithm</em> or even just the
<em>k-means algorithm</em> [1]. It works as follows:

-# Seed the \f$ k \f$ centroids (see below)
-# Repeat until convergence:
 -# Assign each point to its closest centroid
 -# Move each centroid to the barycenter (mean) of all points currently
    assigned to it
-# Convergence is achieved when no points change their assignments during step 2a.

This algorithm is guaranteed to converge to a local optimum, as it can be 
shown that the objective function decreases in every step.

@implementation

Data points and predefined centroids (if used) are expected to be stored row-wise,
in a column of type <tt>\ref grp_svec "SVEC"</tt> (or any type convertible to
<tt>\ref grp_svec "SVEC"</tt>, like <tt>FLOAT[]</tt> or <tt>INTEGER[]</tt>).
Data points with with non-finite values (NULL, NaN, infinity) in any component
will be skipped during analysis.

The following methods are available for the centroid seeding:
 - <strong>random selection</strong>: 
   Select \f$ k \f$ centroids randomly among the input points.
 - <strong>kmeans++</strong> [2]:
   Start with a single centroid chosen randomly among the input points. Then
   iteratively choose new
   centroids from the input points until there is a total of \f$ k \f$
   centroids. The probability for picking a particular point is proportional to
   its minimum squared distance to any existing centroid.
   \n
   Intuitively, kmeans++ favors seedings where centroids are spread out over the
   whole range of the input points, while at the same time not being too
   susceptible to outliers [2].
 - <strong>user-specified set of initial centroids</strong>:
   See below for a description of the expected format of the set of initial
   centroids.

The following distance functions can be used (computation of barycenter/mean in parentheses):
 - <strong>1-norm/Manhattan</strong> (element-wise mean)
 - <strong>2-norm/Euclidean</strong> (element-wise mean)
 - <strong>cosine</strong> (element-wise mean of normalized points)
 - <strong>tanimoto</strong> (element-wise mean of normalized points)

The algorithm stops when one of the following conditions is met:
 - The fraction of updated points is smaller than convergence threshold (default: 0.001).
 - The algorithm reached the maximum number of allowed iterations (default: 20).

A popular method to assess the quality of the clustering is the
<em>silhouette coefficient</em>, a simplified version of which can be computed
optionally [3]. Since for large data sets this computation is expensive, it is
turned off by default (evaluate = False).

@input
The <strong>source relation</strong> is expected to be of the following form (or
to be implicitly convertible into the following form):
<pre>{TABLE|VIEW} <em>data_points</em> (
    ...
    <em>point_id</em> BIGINT,
    <em>point_coordinates</em> FLOAT8[],
    ...
)</pre>
where:
 - <em>point_id</em> is the name of an optional column with a unique ID of the
   data point.
 - <em>point_coordinates</em> is the name of a column with point coordinates. 
   Types such as \c svec or <tt>INTEGER[]</tt> are implicitly convertible to
   <tt>FLOAT8[]</tt>.

If kmeans is called with a set of initial centroids, the centroid relation is
expected to be of the following form:
<pre>{TABLE|VIEW} <em>initial_centroids</em> (
    ...
    <em>centroid_coordinates</em> DOUBLE PRECISION[],
    ...
)</pre>
where:
 - <em>centroid_coordinates</em> is the name of a column with coordinates 
 
@warning This documentation needs an update! 

@usage
The k-means algorithm can be invoked in four possible ways:

- using <em>random</em> centroid seeding method for a 
provided \f$ k \f$:
<pre>SELECT * FROM \ref kmeans_random(
  '<em>src_relation</em>', '<em>src_col_data</em>', '<em>src_col_id</em>',
  '<em>out_points</em>', '<em>out_centroids</em>',
  '<em>dist_metric</em>',
  <em>max_iter</em>, <em>conv_threshold</em>,
  <em>evaluate</em>, <em>verbose</em>,
  <em>k</em>
);</pre>

- using <em>kmeans++</em> centroid seeding method for a 
provided \f$ k \f$:
<pre>SELECT * FROM \ref kmeans_plusplus(
  '<em>src_relation</em>', '<em>src_col_data</em>', '<em>src_col_id</em>',
  '<em>out_points</em>', '<em>out_centroids</em>',
  '<em>dist_metric</em>',
  <em>max_iter</em>, <em>conv_threshold</em>,
  <em>evaluate</em>, <em>verbose</em>,
  <em>k</em>, <em>sample_frac</em>
);</pre>

- with a provided centroid set:
<pre>SELECT * FROM \ref kmeans_cset(
  '<em>src_relation</em>', '<em>src_col_data</em>', '<em>src_col_id</em>',
  '<em>out_points</em>', '<em>out_centroids</em>',
  '<em>dist_metric</em>',
  <em>max_iter</em>, <em>conv_threshold</em>,
  <em>evaluate</em>, <em>verbose</em>,
  '<em>init_cset_rel</em>', '<em>init_cset_col</em>'
);</pre>

The output centroid set will be stored in the <tt>out_centroids</tt> table 
with the following structure:
<pre>
 cid |  coords                   
-----+-------------
        ...
</pre>

The cluster assignments for each data point will be stored in the
<tt>out_points</tt> table with the following structure:
<pre>
 pid |  coords  | cid 
-----+----------+-----
         ...
</pre>

@examp

-#  Prepare some input data.
\code
sql> SELECT * FROM public.km_sample LIMIT 5;
          coords          
--------------------------
 {1,1}:{6.76976,39.89516}
 {1,1}:{6.92655,39.54273}
 {1,1}:{6.78933,39.71434}
 {1,1}:{7.24073,39.61291}
 {1,1}:{6.72292,39.05652}
(5 rows)
\endcode    
-#  Run k-means clustering using kmeans++ for centroid seeding
(below example is executed in Verbose mode):
\code
sql> SELECT * FROM madlib.kmeans_plusplus( 
    'km_sample', 'coords', null,
    'km_p', 'km_c',
    'l2norm',
    10, 0.001,
    True, True,
    10, null
);
INFO:  ('Started k-means clustering with parameters:',)
INFO:  (' * src_relation = public.km_sample',)
INFO:  (' * src_col_data = coords',)
INFO:  (' * src_col_id = None (will be auto-generated)',)
INFO:  (' * init_method = kmeans++ (sample=0.01)',)
INFO:  (' * initial k = 10',)
INFO:  (' * dist_metric = l2norm',)
INFO:  (' * evaluate = True (model coefficient evaluation)',)
INFO:  (' * output_points = public.km_p',)
INFO:  (' * output_centroids = public.km_c',)
INFO:  (' * verbose = True',)
INFO:  ('Input:',)
INFO:  ('... analyzing data points',)
INFO:  (' * points: 10000 (2 dimensions), kept 10000 after removing NULLs',)
INFO:  ('... generating initial centroids',)
INFO:  (' * centroids: 10 seeded using kmeans++ (0.351 sec)',)
INFO:  ('Execution:',)
INFO:  ('... Iteration 1: updated 10000 points (0.212 sec)',)
INFO:  ('... Iteration 2: updated 136 points (0.399 sec)',)
INFO:  ('... Iteration 3: updated 74 points (0.2 sec)',)
INFO:  ('... Iteration 4: updated 58 points (0.28 sec)',)
INFO:  ('... Iteration 5: updated 66 points (0.261 sec)',)
INFO:  ('... Iteration 6: updated 51 points (0.248 sec)',)
INFO:  ('... Iteration 7: updated 36 points (0.257 sec)',)
INFO:  ('... Iteration 8: updated 23 points (0.255 sec)',)
INFO:  ('... Iteration 9: updated 21 points (0.31 sec)',)
INFO:  ('... Iteration 10: updated 13 points (0.25 sec)',)
INFO:  ('Exit condition: reached maximum number of iterations = 10',)
INFO:  ('Writing final output table: public.km_p...',)
INFO:  ('... 0.033 sec',)
INFO:  ('Calculating model cost function and simplified Silhouette coefficient...',)
INFO:  ('... 0.121 sec',)
-[ RECORD 1 ]-+-----------------
src_relation  | km_sample
point_count   | 10000
init_method   | kmeans++
k             | 10
dist_metric   | l2norm
iterations    | 10
cost_func     | 36424.9019377
silhouette    | 0.710664950775
out_points    | km_p
out_centorids | km_c              
\endcode

@literature

[1] Wikipedia, K-means Clustering,
    http://en.wikipedia.org/wiki/K-means_clustering

[2] David Arthur, Sergei Vassilvitskii: k-means++: the advantages of careful
    seeding, Proceedings of the 18th Annual ACM-SIAM Symposium on Discrete
    Algorithms (SODA'07), pp. 1027-1035,
    http://www.stanford.edu/~darthur/kMeansPlusPlus.pdf

[3] E. R. Hruschka, L. N. C. Silva, R. J. G. B. Campello: Clustering
    Gene-Expression Data: A Hybrid Approach that Iterates Between k-Means and
    Evolutionary Search. In: Studies in Computational Intelligence - Hybrid
    Evolutionary Algorithms. pp. 313-335. Springer. 2007.
    
[4] Lloyd, Stuart: Least squares quantization in PCM. Technical Note, Bell
    Laboratories. Published much later in: IEEE Transactions on Information
    Theory 28(2), pp. 128-137. 1982.

@sa File kmeans.sql_in documenting the SQL functions.

@internal
@sa namespace kmeans (documenting the implementation in Python)
@endinternal
*/

CREATE TYPE MADLIB_SCHEMA.kmeans_result AS (
    centroids DOUBLE PRECISION[][],
    frac_reassigned DOUBLE PRECISION,
    num_iterations INTEGER
);

CREATE FUNCTION MADLIB_SCHEMA.kmeans_step_transition(
    state DOUBLE PRECISION[],
    x DOUBLE PRECISION[],
    centroids DOUBLE PRECISION[][],
    previous_centroids DOUBLE PRECISION[][], -- may be NULL
    dist REGPROC
) RETURNS DOUBLE PRECISION[]
LANGUAGE c
IMMUTABLE
CALLED ON NULL INPUT
AS 'MODULE_PATHNAME';

CREATE FUNCTION MADLIB_SCHEMA.kmeans_step_merge(
    state_left DOUBLE PRECISION[],
    state_right DOUBLE PRECISION[]
) RETURNS DOUBLE PRECISION[]
LANGUAGE c
IMMUTABLE
STRICT
AS 'MODULE_PATHNAME';

CREATE FUNCTION MADLIB_SCHEMA.kmeans_step_final(
    state DOUBLE PRECISION[]
) RETURNS MADLIB_SCHEMA.kmeans_result
LANGUAGE c
IMMUTABLE
STRICT
AS 'MODULE_PATHNAME';

/**
 * @internal
 * @brief Perform one iteration of Lloyd's k-means local-search heuristic
 *
 * @param x Point \f$ x \f$
 * @param centroids Matrix containing \f$ k \f$ centroids as columns
 * @param previous_centroids Matrix containing the previous \f$ k \f$ centroids 
 *     as columns. This would be NULL in the first iteration.
 * @param dist A distance function with signature
 *     <tt>DOUBLE PRECISION[] x DOUBLE PRECISION[] -> DOUBLE PRECISION</tt>.
 * @returns A composite value:
 *  - <tt>centroids</tt> - Matrix containing the new \f$ l \leq k \f$
 *    repositioned centroids as columns. If this matrix has \f$ l < k \f$
 *    columns, one or more old centroids no longer were closest to any point.
 *    (See kmeans.kmeans() how this is being dealt with.)
 *  - <tt>frac_reassigned</tt> - Fraction of points that was assigned a
 *    different centroid in the current iteration.
 *
 * The return composite value also contains a field <tt>num_iterations</tt>,
 * which will not be set by the aggregate function, though.
 */
CREATE AGGREGATE MADLIB_SCHEMA.kmeans_step(
    /*+ x */ DOUBLE PRECISION[],
    /*+ centroids */ DOUBLE PRECISION[][],
    /*+ previous_centroids */ DOUBLE PRECISION[][],
    /*+ dist */ REGPROC
) (
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.kmeans_step_transition,
    m4_ifdef(`__GREENPLUM__', `PREFUNC=MADLIB_SCHEMA.kmeans_step_merge,')
    FINALFUNC=MADLIB_SCHEMA.kmeans_step_final,
    INITCOND='{0,0,0,0}'
);

/**
 * @internal
 * @brief Execute a SQL command where $1, ..., $4 are substituted with the
 *     given arguments.
 */
CREATE FUNCTION MADLIB_SCHEMA.internal_execute_using_kmeans_args(
    sql VARCHAR, DOUBLE PRECISION[][], REGPROC, INTEGER, DOUBLE PRECISION
) RETURNS VOID
IMMUTABLE
CALLED ON NULL INPUT
LANGUAGE c
AS 'MODULE_PATHNAME', 'exec_sql_using';

CREATE FUNCTION MADLIB_SCHEMA.internal_compute_kmeans(
    rel_args VARCHAR,
    rel_state VARCHAR,
    rel_source VARCHAR,
    col_id VARCHAR,
    col_point VARCHAR)
RETURNS INTEGER
VOLATILE
LANGUAGE plpythonu
AS $$PythonFunction(kmeans, kmeans, compute_kmeans)$$;

/**
 * @brief Perform Lloyd's k-means local-search heuristic
 *
 * @param rel_source Name of the relation containing input points
 * @param col_id Name of the column containing the unique identifiers
 * @param col_point Name of the column containing the point coordinates
 * @param initial_centroids Matrix containing the initial centroids as columns
 * @param squared_dist_metric A function with signature
 *     <tt>DOUBLE PRECISION[] x DOUBLE PRECISION[] -> DOUBLE PRECISION</tt> that
 *     returns the square of the distance between two points
 * @param max_num_iterations Maximum number of iterations
 * @param min_frac_reassigned Fraction of reassigned points below which
 *     convergence is assumed and the algorithm terminates
 * @returns A composite value:
 *  - <tt>centroids</tt> - Matrix with \f$ k \f$ centroids as columns.
 *  - <tt>frac_reassigned</tt> - Fraction of points that were assigned a
 *    different centroid in the last iteration.
 *  - <tt>num_iterations</tt> - The number of iterations before the
 *    algorithm terminated
 */
CREATE FUNCTION MADLIB_SCHEMA.kmeans(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    initial_centroids DOUBLE PRECISION[][],
    squared_dist_metric REGPROC /*+ DEFAULT 'squared_dist_norm2' */,
    agg_mean REGPROC /*+ DEFAULT 'avg(float8)' */,
    max_num_iterations INTEGER /*+ DEFAULT 20 */,
    min_frac_reassigned DOUBLE PRECISION /*+ DEFAULT 0.001 */
) RETURNS MADLIB_SCHEMA.kmeans_result AS $$
DECLARE
    theIteration INTEGER;
    theResult MADLIB_SCHEMA.kmeans_result;
    oldClientMinMessages VARCHAR;
BEGIN
    -- We first setup the argument table. Rationale: We want to avoid all data
    -- conversion between native types and Python code. Instead, we use Python
    -- as a pure driver layer.
    oldClientMinMessages :=
        (SELECT setting FROM pg_settings WHERE name = 'client_min_messages');
    EXECUTE 'SET client_min_messages TO warning';
    PERFORM MADLIB_SCHEMA.create_schema_pg_temp();
    -- Unfortunately, the EXECUTE USING syntax is only available starting
    -- PostgreSQL 8.4:
    -- http://www.postgresql.org/docs/8.4/static/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN
    -- We therefore have to emulate.
    PERFORM MADLIB_SCHEMA.internal_execute_using_kmeans_args($sql$
        DROP TABLE IF EXISTS _madlib_kmeans_args;
        CREATE TABLE _madlib_kmeans_args AS
        SELECT
            $1 AS initial_centroids, array_upper($1, 1) AS k,
            $2 AS squared_dist_metric, $3 AS max_num_iterations,
            $4 AS min_frac_reassigned;
        $sql$,
        initial_centroids, squared_dist_metric, max_num_iterations,
        min_frac_reassigned);
    EXECUTE 'SET client_min_messages TO ' || oldClientMinMessages;

    -- Perform acutal computation.
    -- Unfortunately, Greenplum and PostgreSQL <= 8.2 do not have conversion 
    -- operators from regclass to varchar/text.
    theIteration := MADLIB_SCHEMA.internal_compute_kmeans('_madlib_kmeans_args',
            '_madlib_kmeans_state',
            textin(regclassout(rel_source)), col_id, col_point);
    
    -- Retrieve result from state table and return it
    EXECUTE
        $sql$
        SELECT (_state).* FROM _madlib_kmeans_state
        WHERE _iteration = $sql$ || theIteration || $sql$
        $sql$
        INTO theResult;
    -- The number of iterations are not updated in the C++ code. We do it here.
    IF NOT (theResult IS NULL) THEN
        theResult.num_iterations = theIteration;
    END IF;
    RETURN theResult;
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION MADLIB_SCHEMA.internal_execute_using_kmeanspp_seeding_args(
    sql VARCHAR, INT2, REGPROC, DOUBLE PRECISION[][]
) RETURNS VOID
IMMUTABLE
CALLED ON NULL INPUT
LANGUAGE c
AS 'MODULE_PATHNAME', 'exec_sql_using';

CREATE FUNCTION MADLIB_SCHEMA.internal_compute_kmeanspp_seeding(
    rel_args VARCHAR,
    rel_state VARCHAR,
    rel_source VARCHAR,
    col_id VARCHAR,
    col_point VARCHAR)
RETURNS INTEGER
AS $$PythonFunction(kmeans, kmeans, compute_kmeanspp_seeding)$$
LANGUAGE plpythonu VOLATILE;

/**
 * @brief k-Means++ Seeding
 *
 * @param rel_source Name of the relation containing input points
 * @param col_id Name of the column containing the unique identifiers
 * @param col_point Name of the column containing the point coordinates
 * @param k Number of centroids
 * @param squared_dist_metric A function with signature
 *     <tt>DOUBLE PRECISION[] x DOUBLE PRECISION[] -> DOUBLE PRECISION</tt> that
 *     returns the square of the distance between two points
 * @param initial_centroids A matrix containing up to \f$ k \f$ columns as
 *     columns. kmeanspp_seeding() proceeds exactly as if these centroids had
 *     already been generated in previous iterations. This parameter may be
 *     NULL in which all \f$ k \f$ centroids will be generated.
 * @returns A matrix containing \f$ k \f$ centroids as columns
 */
CREATE FUNCTION MADLIB_SCHEMA.kmeanspp_seeding(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2,
    squared_dist_metric REGPROC,
    initial_centroids DOUBLE PRECISION[][] /*+ DEFAULT NULL */
) RETURNS DOUBLE PRECISION[][] AS $$
DECLARE
    theIteration INTEGER;
    theResult DOUBLE PRECISION[][];
    oldClientMinMessages VARCHAR;
BEGIN
    -- We first setup the argument table. Rationale: We want to avoid all data
    -- conversion between native types and Python code. Instead, we use Python
    -- as a pure driver layer.
    oldClientMinMessages :=
        (SELECT setting FROM pg_settings WHERE name = 'client_min_messages');
    EXECUTE 'SET client_min_messages TO warning';
    PERFORM MADLIB_SCHEMA.create_schema_pg_temp();
    -- Unfortunately, the EXECUTE USING syntax is only available starting
    -- PostgreSQL 8.4:
    -- http://www.postgresql.org/docs/8.4/static/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN
    -- We therefore have to emulate.
    PERFORM MADLIB_SCHEMA.internal_execute_using_kmeanspp_seeding_args($sql$
        DROP TABLE IF EXISTS pg_temp._madlib_kmeanspp_args;
        CREATE TEMPORARY TABLE _madlib_kmeanspp_args AS
        SELECT $1 AS k, $2 AS squared_dist_metric, $3 AS initial_centroids;
        $sql$,
        k, squared_dist_metric, initial_centroids);
    EXECUTE 'SET client_min_messages TO ' || oldClientMinMessages;

    -- Perform acutal computation.
    -- Unfortunately, Greenplum and PostgreSQL <= 8.2 do not have conversion 
    -- operators from regclass to varchar/text.
    theIteration := (
        SELECT MADLIB_SCHEMA.internal_compute_kmeanspp_seeding(
            '_madlib_kmeanspp_args', '_madlib_kmeanspp_state',
            textin(regclassout(rel_source)), col_id, col_point)
    );
    
    -- Retrieve result from state table and return it
    EXECUTE
        $sql$
        SELECT _state FROM _madlib_kmeanspp_state
        WHERE _iteration = $sql$ || theIteration || $sql$
        $sql$
        INTO theResult;
    RETURN theResult;
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION MADLIB_SCHEMA.kmeanspp_seeding(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2,
    squared_dist_metric REGPROC
) RETURNS DOUBLE PRECISION[][]
LANGUAGE sql AS $$
    SELECT MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4, $5, NULL)
$$;

CREATE FUNCTION MADLIB_SCHEMA.kmeanspp_seeding(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2
) RETURNS DOUBLE PRECISION[][]
LANGUAGE sql AS $$
    SELECT MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4,
        'MADLIB_SCHEMA.squared_dist_norm2', NULL)
$$;

/**
 * @brief Run k-Means++.
 *
 * This is a shortcut for running k-means++. It is equivalent to
 * <pre>SELECT \ref kmeans(
    rel_source,
    col_id,
    col_point,
    \ref kmeanspp_seeding(
        rel_source,
        col_id,
        col_point,
        k,
        squared_dist_metric
    ),
    squared_dist_metric,
    max_num_iterations,
    min_frac_reassigned
)</pre>
 */
CREATE FUNCTION MADLIB_SCHEMA.kmeanspp(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2,
    squared_dist_metric REGPROC /*+ DEFAULT "squared_dist_norm2" */,
    agg_mean REGPROC /*+ DEFAULT 'avg(float8)' */,
    max_num_iterations INTEGER /*+ DEFAULT 20 */,
    min_frac_reassigned DOUBLE PRECISION /*+ DEFAULT 0.001 */
) RETURNS MADLIB_SCHEMA.kmeans_result
VOLATILE
STRICT
LANGUAGE sql AS $$
    SELECT MADLIB_SCHEMA.kmeans(
        $1, $2, $3, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4, $5),
        $5, $6, $7, $8)
$$;

CREATE FUNCTION MADLIB_SCHEMA.kmeanspp(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2,
    squared_dist_metric REGPROC,
    agg_mean REGPROC,
    max_num_iterations INTEGER
) RETURNS MADLIB_SCHEMA.kmeans_result
VOLATILE
STRICT
LANGUAGE sql AS $$
    SELECT MADLIB_SCHEMA.kmeans(
        $1, $2, $3, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4, $5),
        $5, $6, $7, 0.001)
$$;

CREATE FUNCTION MADLIB_SCHEMA.kmeanspp(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2,
    squared_dist_metric REGPROC,
    agg_mean REGPROC
) RETURNS MADLIB_SCHEMA.kmeans_result
VOLATILE
STRICT
LANGUAGE sql AS $$
    SELECT MADLIB_SCHEMA.kmeans(
        $1, $2, $3, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4, $5),
        $5, $6, 20, 0.001)
$$;

CREATE FUNCTION MADLIB_SCHEMA.kmeanspp(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2,
    squared_dist_metric REGPROC
) RETURNS MADLIB_SCHEMA.kmeans_result
VOLATILE
STRICT
LANGUAGE sql AS $$
    SELECT MADLIB_SCHEMA.kmeans(
        $1, $2, $3, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4, $5),
        $5, 'MADLIB_SCHEMA.avg_vector', 20, 0.001)
$$;

CREATE FUNCTION MADLIB_SCHEMA.kmeanspp(
    rel_source REGCLASS,
    col_id VARCHAR,
    col_point VARCHAR,
    k INT2
) RETURNS MADLIB_SCHEMA.kmeans_result
VOLATILE
STRICT
LANGUAGE sql AS $$
    SELECT MADLIB_SCHEMA.kmeans(
        $1, $2, $3,
        MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4,
            'MADLIB_SCHEMA.squared_dist_norm2'),
        'MADLIB_SCHEMA.squared_dist_norm2', 'MADLIB_SCHEMA.avg_vector',
        20, 0.001)
$$;
