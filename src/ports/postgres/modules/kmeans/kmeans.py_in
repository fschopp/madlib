# coding=utf-8

"""
@file kmeans.py_in

@brief k-means: driver functions

@namespace kmeans

@brief k-means: driver functions
"""

# from regress import control
from regress.control import IterationController

def compute_kmeanspp_seeding(schema_madlib, rel_args, rel_state, rel_source,
    col_id, col_point, **kwargs):
    """
    Driver function for k-Means++ seeding

    @param schema_madlib Name of the MADlib schema, properly escaped/quoted
    @rel_args Name of the (temporary) table containing all non-template
        arguments
    @rel_state Name of the (temporary) table containing the inter-iteration
        states
    @param rel_source Name of the relation containing input points
    @param col_id Name of the column containing the unique identifiers
    @param col_point Name of the column containing the point coordinates
    @param kwargs We allow the caller to specify additional arguments (all of
        which will be ignored though). The purpose of this is to allow the
        caller to unpack a dictionary whose element set is a superset of
        the required arguments by this function.
    @return The iteration number (i.e., the key) with which to look up the
        result in \c rel_state
    """
    iterationCtrl = IterationController(
        rel_args = rel_args,
        rel_state = rel_state,
        stateType = "DOUBLE PRECISION[][]",
        truncAfterIteration = True,
        schema_madlib = schema_madlib, # Identifiers start here
        rel_source = rel_source,
        col_id = col_id,
        col_point = col_point)
    with iterationCtrl as it:
        if it.test("_args.initial_centroids IS NULL"):
            it.update("""
                SELECT ARRAY[(
                    SELECT CAST(_src.{col_point} AS DOUBLE PRECISION[])
                    FROM {rel_source} AS _src
                    WHERE _src.{col_id} = (
                        SELECT {schema_madlib}.weighted_sample(_src.{col_id}, 1)
                        FROM {rel_source} AS _src
                    )
                )]
                """)
        else:
            it.update("""
                SELECT _args.initial_centroids FROM {rel_args} AS _args
                """)
        while it.test("array_upper(_state._state, 1) < _args.k"):
            it.update("""
                SELECT _state._state || _src.{col_point}
                FROM {rel_source} AS _src, {rel_state} AS _state
                WHERE
                    _src.{col_id} = (
                        SELECT
                            {schema_madlib}.weighted_sample(
                                _src.{col_id},
                                ({schema_madlib}.closest_column(
                                    _state._state,
                                    _src.{col_point},
                                    _args.squared_dist_metric
                                )).distance
                            )
                        FROM
                            {rel_source} AS _src, {rel_args} AS _args,
                            {rel_state} AS _state
                        WHERE
                            _state._iteration = {iteration}
                    )
                    AND _state._iteration = {iteration}
                """)
    return iterationCtrl.iteration


def compute_kmeans(schema_madlib, rel_args, rel_state, rel_source, col_id,
    col_point, agg_mean, **kwargs):
    """
    Driver function for Lloyd's k-means local-search heuristic

    @param schema_madlib Name of the MADlib schema, properly escaped/quoted
    @rel_args Name of the (temporary) table containing all non-template
        arguments
    @rel_state Name of the (temporary) table containing the inter-iteration
        states
    @param rel_source Name of the relation containing input points
    @param col_id Name of the column containing the unique identifiers
    @param col_point Name of the column containing the point coordinates
    @param kwargs We allow the caller to specify additional arguments (all of
        which will be ignored though). The purpose of this is to allow the
        caller to unpack a dictionary whose element set is a superset of
        the required arguments by this function.
    @return The iteration number (i.e., the key) with which to look up the
        result in \c rel_state
    """

    iterationCtrl = IterationController(
        rel_args = rel_args,
        rel_state = rel_state,
        stateType = "{schema_madlib}.kmeans_result",
        truncAfterIteration = False,
        schema_madlib = schema_madlib,
        rel_source = rel_source,
        col_id = col_id,
        col_point = col_point,
        agg_mean = agg_mean)
    with iterationCtrl as it:
        # Create the initial inter-iteration state of type kmeans_result
        it.update("""
            SELECT
                CAST((_args.initial_centroids, 1.0, 0) AS
                    {schema_madlib}.kmeans_result)
            FROM {rel_args} AS _args
            """)
        while it.test("""
            {iteration} < _args.max_num_iterations AND
            (_state._state).frac_reassigned > _args.min_frac_reassigned
            """):
            it.update("""
                SELECT
                    CAST((
                        {schema_madlib}.matrix_agg(_centroid),
                        CAST(sum(_num_reassigned) AS DOUBLE PRECISION)
                            / sum(_num_points),
                        NULL
                    ) AS {schema_madlib}.kmeans_result)
                FROM (
                    SELECT
                        count(*) AS _num_points,
                        sum(CAST(coalesce(
                            _new_centroid_id != _old_centroid_id, TRUE
                        ) AS INTEGER)) AS _num_reassigned,
                        {agg_mean}(_point) AS _centroid
                    FROM (
                        SELECT
                            _src.{col_point} AS _point,
                            ({schema_madlib}.closest_column(
                                (_state._state).centroids,
                                _src.{col_point},
                                _args.squared_dist_metric
                            )).column_id AS _new_centroid_id,
                            ({schema_madlib}.closest_column(
                                (_state_old._state).centroids,
                                _src.{col_point},
                                _args.squared_dist_metric
                            )).column_id AS _old_centroid_id
                        FROM
                            {rel_source} AS _src,
                            {rel_args} AS _args, {rel_state} AS _state
                            LEFT OUTER JOIN (
                                SELECT *
                                FROM {rel_state} AS _state
                                WHERE _state._iteration = {iteration} - 1
                            ) AS _state_old ON True
                        WHERE _state._iteration = {iteration}
                    ) AS _points_with_assignments
                    GROUP BY _new_centroid_id
                ) AS _new_centroids
                """)

            # within the while loop
            if it.test(
                "array_upper((_state._state).centroids, 1) < _args.k"):
                it.update("""
                    SELECT
                        ((_state._state).centroids
                            || {schema_madlib}.kmeanspp_seeding(
                            '{rel_source}',
                            '{col_id}',
                            '{col_point}',
                            CAST(_args.k AS INT2),
                            _args.squared_dist_metric,
                            (_state._state).centroids
                        ), (_state._state).frac_reassigned, 0)
                    FROM {rel_state} AS _state, {rel_args} AS _args
                    WHERE _state._iteration = {iteration}
                    """)
    return iterationCtrl.iteration
